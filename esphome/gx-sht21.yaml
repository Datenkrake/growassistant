esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
#api:
#  encryption:
#    key: "tTsVnmfwRjAJVXiTaDmPlbupV93rhvXhWV2fzj3TVeI="

ota:
  - platform: esphome
    password: "76ea25f7bae7cb81d7e0bdf9f26644b7"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Gx-Sht21 Fallback Hotspot"
    password: "uWezis5Q2NxQ"

captive_portal:

switch:
  - platform: gpio
    pin: GPIO4
    id: sht_gnd
    restore_mode: ALWAYS_OFF  # GPIO4 is always on, it is GND for SHT21

esphome:
  name: g2-canopy

####################################################################
# configure substitutions and friendly name
####################################################################

  friendly_name: ${area_id}_CANOPY${suffix}

substitutions:
  area_id: G2
  suffix: ""
  pin_sda: GPIO6
  pin_scl: GPIO5
  pin_echo: GPIO2
  pin_trigger: GPIO1
  address_sht3xd: "0x44"
  address_bh1750: "0x23"

####################################################################
# generic yaml for humidifiers below
####################################################################


globals:
  - id: ${area_id}_door_open${suffix}
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${area_id}_new_brightness_global${suffix}
    type: float
    restore_value: no
    initial_value: '0.0'

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  topic_prefix: "${area_id}/canopy"
  on_message:
    - topic: ${area_id}/door_switch
      then:
        - lambda: |-
            if (strcmp(x.c_str(), "ON") == 0) {
              id(${area_id}_door_open${suffix}) = true;
            } else if (strcmp(x.c_str(), "OFF") == 0) {
              id(${area_id}_door_open${suffix}) = false;
            }
            id(adjust_brightness).execute();

# Current time from MQTT
time:
  - platform: sntp
    id: mqtt_time
    timezone: CET

  # Example configuration entry for ESP32
i2c:
  sda: ${pin_sda}
  scl: ${pin_scl}
  scan: true
  id: bus_a
  frequency: 50kHz

text_sensor:
  - platform: mqtt_subscribe
    name: "Current Brightness [${area_id}${suffix}]"
    id: ${area_id}_current_brightness_text_sensor  # Make sure this ID matches
    topic: "${area_id}/light/full_spectrum/state"
    on_value:
      then:
        - lambda: |-
            // Parse the JSON payload
            DynamicJsonDocument doc(512);
            auto error = deserializeJson(doc, x.c_str());
            if (error) {
              ESP_LOGW("main", "Failed to parse JSON: %s", error.c_str());
              return;
            }

            // Check if "brightness" key exists
            if (doc.containsKey("brightness")) {
              int brightness = doc["brightness"].as<int>();

              // Update the text sensor's state to the brightness value as a string
              //id(full_spectrum_brightness_text_sensor).publish_state(std::to_string(brightness/255));
              id(full_spectrum_brightness_number_sensor).publish_state(brightness/255.0f);
            } else {
              ESP_LOGW("main", "Brightness key not found in JSON.");
            }

sensor:
  - platform: bh1750
    name: "Canopy Illuminance [${area_id}${suffix}]"
    id: ${area_id}_canopy_illuminance
    state_topic: "${area_id}/illuminance/canopy"
    address: ${address_bh1750}
    update_interval: 1s
    i2c_id: bus_a
    unit_of_measurement: "lx"
    filters:
      - exponential_moving_average:
          alpha: 0.1  # Adjust this value for stronger or weaker , 0 to 1
          send_every: 5

  - platform: ultrasonic
    trigger_pin: ${pin_trigger}
    echo_pin: ${pin_echo}
    name: "Canopy Cola Distance [${area_id}${suffix}]"
    id: ${area_id}_canopy_cola_distance
    state_topic: "${area_id}/cola_distance/canopy"
    update_interval: 1s
    timeout: 2m
    filters:
    - sliding_window_moving_average:
        window_size: 60
        send_every: 60

  - platform: sht3xd
    temperature:
      name: "Canopy Temperature [${area_id}${suffix}]"
      id: ${area_id}_canopy_temperature
      state_topic: "${area_id}/temperature/canopy"
    humidity:
      name: "Canopy Humidity [${area_id}${suffix}]"
      id: ${area_id}_canopy_humidity
      state_topic: "${area_id}/humidity/canopy"
    address: ${address_sht3xd}
    update_interval: 30s

  - platform: template
    name: "Canopy VPD [${area_id}${suffix}]"
    id: ${area_id}_canopy_vpd
    state_topic: "${area_id}/vpd/canopy"
    unit_of_measurement: "kPa"
    update_interval: 30s
    lambda: |
      float temp = id(${area_id}_canopy_temperature).state;
      float rh = id(${area_id}_canopy_humidity).state;
      float leaf_offset = id(${area_id}_canopy_vpd_leaf_offset).state;
      float LT = temp + leaf_offset;
      float ASVP = 610.78 * exp((temp / (temp + 237.3)) * 17.2694);
      float LSVP = 610.78 * exp((LT / (LT + 237.3)) * 17.2694);
      float LVPD = (LSVP - (ASVP * (rh / 100.0))) / 1000.0;
      return roundf(LVPD * 100.0) / 100.0;

  - platform: template
    name: "Canopy PPFD [${area_id}${suffix}]"
    id: ${area_id}_canopy_ppfd
    state_topic: "${area_id}/ppfd/canopy"
    unit_of_measurement: "µmol/m²/s"
    update_interval: 1s
    lambda: |
      float lux = id(${area_id}_canopy_illuminance).state;
      float bh1750_cal = id(${area_id}_canopy_illuminance_calibration_factor).state;
      float calibrated_lux = lux * bh1750_cal;
      float ppfd = calibrated_lux * 0.017;
      return roundf(ppfd);

  - platform: template
    name: "Canopy PPFD Target [${area_id}${suffix}]"
    id: ${area_id}_canopy_ppfd_target
    state_topic: "${area_id}/ppfd_target/canopy"
    unit_of_measurement: "µmol/m²/s"
    update_interval: 60s
    lambda: |
      if (!id(${area_id}_dayphase_target).state) {
        return 0;
      }

      float dli_target = id(${area_id}_canopy_dli_target).state;
      float day_length = id(${area_id}_day_length).state;

      if (day_length > 0) {
        float ppfd_target = (dli_target * 1000000.0) / (day_length * 3600.0);
        return roundf(ppfd_target);
      } else {
        return 0;
      }

  - platform: template
    name: "Canopy DLI [${area_id}${suffix}]"
    id: ${area_id}_canopy_dli
    state_topic: "${area_id}/dli/canopy"
    unit_of_measurement: "mol/m²/day"
    update_interval: 60s
    lambda: |
      float ppfd = id(${area_id}_canopy_ppfd).state;
      float day_length = (int) (id(${area_id}_day_length)->state);
      float dli = ppfd * 0.0036 * day_length;
      return roundf(dli * 100.0) / 100.0;

  - platform: template
    name: "Canopy DLI Target [${area_id}${suffix}]"
    id: ${area_id}_canopy_dli_target
    state_topic: "${area_id}/dli_target/canopy"
    unit_of_measurement: "mol/m²/day"
    update_interval: 60s
    lambda: |
      time_t now = id(mqtt_time).now().timestamp;
      time_t start_vegetative = (time_t) id(${area_id}_start_date)->state;
      time_t start_flipping = start_vegetative + (time_t)(id(${area_id}_duration_vegetative))->state * 86400;
      time_t start_generative = start_flipping + (time_t)(id(${area_id}_duration_flipping))->state * 86400;
      time_t generative_peak = start_generative + (time_t)(id(${area_id}_duration_generative))->state * 43200;
      time_t start_drying = start_generative + (time_t)(id(${area_id}_duration_generative))->state * 86400;

      if (now < start_vegetative) {
        return 0;
      } else if (now < start_flipping) {
        float x = float(now - start_vegetative) / float(start_flipping - start_vegetative);
        float dli_target = id(${area_id}_dli_vegetative_start).state + x * (id(${area_id}_dli_vegetative_end).state - id(${area_id}_dli_vegetative_start).state);
        return roundf(dli_target);
      } else if (now < start_generative) {
        float x = float(now - start_flipping) / float(start_generative - start_flipping);
        float dli_target = id(${area_id}_dli_vegetative_end).state + x * (id(${area_id}_dli_generative_start).state - id(${area_id}_dli_vegetative_end).state);
        return roundf(dli_target);
      } else if (now < generative_peak) {
        float x = float(now - start_generative) / float(generative_peak - start_generative);
        float dli_target = id(${area_id}_dli_generative_start).state + x * (id(${area_id}_dli_generative_peak).state - id(${area_id}_dli_generative_start).state);
        return roundf(dli_target);
      } else if (now < start_drying) {
        float x = float(now - generative_peak) / float(start_drying - generative_peak);
        float dli_target = id(${area_id}_dli_generative_peak).state + x * (id(${area_id}_dli_generative_end).state - id(${area_id}_dli_generative_peak).state);
        return roundf(dli_target);
      } else {
        return 0;
      }


  - platform: template
    name: "Canopy RH Target [${area_id}${suffix}]"
    id: ${area_id}_canopy_rh_target
    state_topic: "${area_id}/rh_target/canopy"
    unit_of_measurement: "%"
    update_interval: 30s
    lambda: |
      float T = id(${area_id}_canopy_temperature).state;
      float LT = T - 2.0;
      float ASVP = 610.78 * pow(2.71828, (T / (T + 237.3)) * 17.2694);
      float LSVP = 610.78 * pow(2.71828, (LT / (LT + 237.3)) * 17.2694);
      float LVPD_TARGET = id(${area_id}_canopy_vpd_target).state;
      float RH_TARGET = (LSVP - LVPD_TARGET * 1000) / ASVP * 100;
      return roundf(RH_TARGET * 10.0) / 10.0;

  - platform: template
    name: "Canopy Dew Point [${area_id}${suffix}]"
    id: ${area_id}_canopy_dew_point
    state_topic: "${area_id}/dew_point/canopy"
    unit_of_measurement: "°C"
    update_interval: 30s
    lambda: |
      float T = id(${area_id}_canopy_temperature).state;
      float RH = id(${area_id}_canopy_humidity).state;
      float a = 17.27;
      float b = 237.7;
      float alpha = ((a * T) / (b + T)) + log(RH / 100.0);
      float dew_point = (b * alpha) / (a - alpha);
      return roundf(dew_point * 10.0) / 10.0;

  - platform: template
    name: "Growth Cycle [${area_id}${suffix}]"
    id: ${area_id}_growth_cycle
    state_topic: "${area_id}/growth_cycle"
    update_interval: 60s
    lambda: |-
      time_t now = id(mqtt_time).now().timestamp;
      time_t start_vegetative = (time_t) id(${area_id}_start_date)->state;
      time_t start_flipping = start_vegetative + (time_t)(id(${area_id}_duration_vegetative))->state * 86400;
      time_t start_generative = start_flipping + (time_t)(id(${area_id}_duration_flipping))->state * 86400;
      time_t start_drying = start_generative + (time_t)(id(${area_id}_duration_generative))->state * 86400;

      if (now < start_vegetative) {
        return 0;  // Pre-vegetative
      } else if (now < start_flipping) {
        return 1;  // Vegetative
      } else if (now < start_generative) {
        return 2;  // Flipping
      } else if (now < start_drying) {
        return 3;  // Generative
      } else {
        return 4;  // Drying
      }

  # Sensor to calculate current day length
  - platform: template
    name: "Day Length [${area_id}${suffix}]"
    id: ${area_id}_day_length
    state_topic: "${area_id}/day_length"
    unit_of_measurement: "hours"
    update_interval: 60s
    lambda: |-
      time_t now = id(mqtt_time).now().timestamp;
      time_t start_vegetative = (time_t) id(${area_id}_start_date)->state;
      time_t start_flipping = start_vegetative + (time_t)(id(${area_id}_duration_vegetative))->state * 86400;
      time_t start_generative = start_flipping + (time_t)(id(${area_id}_duration_flipping))->state * 86400;
      time_t start_drying = start_generative + (time_t)(id(${area_id}_duration_generative))->state * 86400;

      float _day_length_vegetative = id(${area_id}_day_length_vegetative)->state;
      float _day_length_generative = id(${area_id}_day_length_generative)->state;

      if (now > start_vegetative && now < start_flipping) {
        return _day_length_vegetative;
      } else if (now > start_flipping && now < start_generative) {
        // Linear interpolation between vegetative and generative
        float x = float(now - start_flipping) / float(start_generative - start_flipping);
        return _day_length_vegetative + x * (_day_length_generative - _day_length_vegetative);
      } else if (now > start_generative && now < start_drying) {
        return _day_length_generative;
      } else if (now > start_drying) {
        return 0;
      } else {
        return 0;
      }

  - platform: template
    name: "Full Spectrum Brightness [${area_id}${suffix}]"
    id: full_spectrum_brightness_number_sensor
    state_topic: "${area_id}/brightness/full_spectrum"
    accuracy_decimals: 2

binary_sensor:
  - platform: template
    name: "Day Phase Target [${area_id}${suffix}]"
    id: ${area_id}_dayphase_target
    state_topic: "${area_id}/dayphase_target"
    lambda: |-
      // Get the current timestamp
      time_t now = id(mqtt_time).now().timestamp;

      // Extract today's date
      struct tm timeinfo;
      localtime_r(&now, &timeinfo);

      // Calculate midnight today
      timeinfo.tm_hour = 0;
      timeinfo.tm_min = 0;
      timeinfo.tm_sec = 0;
      time_t midnight_today = mktime(&timeinfo);

      // Calculate midnight yesterday
      time_t midnight_yesterday = midnight_today - 86400; // Subtract 24 hours in seconds

      // Get sunrise times
      time_t sunrise_today = midnight_today + (time_t) id(${area_id}_sunrise_time)->state;
      time_t sunrise_yesterday = midnight_yesterday + (time_t) id(${area_id}_sunrise_time)->state;

      // Get day length in seconds
      int day_length_seconds = (int)(id(${area_id}_day_length)->state * 3600);

      // Determine if it's day phase
      bool is_day = false;

      if (now >= sunrise_yesterday && now < (sunrise_yesterday + day_length_seconds)) {
        is_day = true;
      } else if (now >= sunrise_today && now < (sunrise_today + day_length_seconds)) {
        is_day = true;
      }

      // Log the important time values
      //ESP_LOGD("day_phase_target", "Current Time: %ld", now);
      //ESP_LOGD("day_phase_target", "Midnight Today: %ld", midnight_today);
      //ESP_LOGD("day_phase_target", "Midnight Yesterday: %ld", midnight_yesterday);
      //ESP_LOGD("day_phase_target", "Sunrise Yesterday: %ld", sunrise_yesterday);
      //ESP_LOGD("day_phase_target", "Sunrise Today: %ld", sunrise_today);
      //ESP_LOGD("day_phase_target", "Day Length (seconds): %d", day_length_seconds);
      //ESP_LOGD("day_phase_target", "Is it day phase? %s", is_day ? "Yes" : "No");

      return is_day;

number:
  - platform: template
    name: "Illuminance Calibration Factor [${area_id}${suffix}]"
    id: ${area_id}_canopy_illuminance_calibration_factor
    state_topic: "${area_id}/illuminance_calibration_factor/canopy"
    command_topic: "${area_id}/illuminance_calibration_factor/canopy/set-state"
    optimistic: true
    initial_value: 3.0
    min_value: 0.1
    max_value: 5.0
    step: 0.1
    mode: BOX
    restore_value: True
    retain: True

  - platform: template
    name: "Canopy VPD Target [${area_id}${suffix}]"
    id: ${area_id}_canopy_vpd_target
    state_topic: "${area_id}/vpd_target/canopy"
    command_topic: "${area_id}/vpd_target/canopy/set-state"
    optimistic: true
    initial_value: 1.0
    min_value: 0.0
    max_value: 5.0
    step: 0.1
    mode: BOX
    unit_of_measurement: "kPa"
    restore_value: True
    retain: True

  - platform: template
    name: "VPD Leaf Offset [${area_id}${suffix}]"
    id: ${area_id}_canopy_vpd_leaf_offset
    state_topic: "${area_id}/vpd_leaf_offset/canopy"
    command_topic: "${area_id}/vpd_leaf_offset/canopy/set-state"
    optimistic: true
    initial_value: -2.0
    min_value: -10.0
    max_value: 10.0
    step: 0.1
    mode: BOX
    unit_of_measurement: "°C"
    restore_value: True
    retain: True

  - platform: template
    name: "Canopy Cola Distance Threshold [${area_id}${suffix}]"
    id: ${area_id}_cola_distance_threshold 
    state_topic: "${area_id}/cola_distance_threshold/canopy"
    command_topic: "${area_id}/cola_distance_threshold/canopy/set-state"
    optimistic: true
    initial_value: 0.3
    min_value: 0.0
    max_value: 1.0
    step: 0.05
    mode: box
    unit_of_measurement: "m"
    icon: mdi:ruler
    restore_value: True
    retain: True

  - platform: template
    name: "DLI Vegetative Start [${area_id}${suffix}]"
    id: ${area_id}_dli_vegetative_start
    state_topic: "${area_id}/dli_vegetative_start"
    command_topic: "${area_id}/dli_vegetative_start/set-state"
    optimistic: True
    initial_value: 10
    min_value: 1
    max_value: 100
    step: 1
    mode: BOX
    unit_of_measurement: "mol/m2/day"
    icon: mdi:weather-sunny
    restore_value: True
    retain: True

  - platform: template
    name: "DLI Vegetative End [${area_id}${suffix}]"
    id: ${area_id}_dli_vegetative_end
    state_topic: "${area_id}/dli_vegetative_end"
    command_topic: "${area_id}/dli_vegetative_end/set-state"
    optimistic: True
    initial_value: 20
    min_value: 1
    max_value: 100
    step: 1
    mode: BOX
    unit_of_measurement: "mol/m2/day"
    icon: mdi:weather-sunny
    restore_value: True
    retain: True

  - platform: template
    name: "DLI Generative Start [${area_id}${suffix}]"
    id: ${area_id}_dli_generative_start
    state_topic: "${area_id}/dli_generative_start"
    command_topic: "${area_id}/dli_generative_start/set-state"
    optimistic: True
    initial_value: 20
    min_value: 1
    max_value: 100
    step: 1
    mode: BOX
    unit_of_measurement: "mol/m2/day"
    icon: mdi:weather-sunny
    restore_value: True
    retain: True

  - platform: template
    name: "DLI Generative Peak [${area_id}${suffix}]"
    id: ${area_id}_dli_generative_peak
    state_topic: "${area_id}/dli_generative_peak"
    command_topic: "${area_id}/dli_generative_peak/set-state"
    optimistic: True
    initial_value: 40
    min_value: 1
    max_value: 100
    step: 1
    mode: BOX
    unit_of_measurement: "mol/m2/day"
    icon: mdi:weather-sunny
    restore_value: True
    retain: True

  - platform: template
    name: "DLI Generative End [${area_id}${suffix}]"
    id: ${area_id}_dli_generative_end
    state_topic: "${area_id}/dli_generative_end"
    command_topic: "${area_id}/dli_generative_end/set-state"
    optimistic: True
    initial_value: 30
    min_value: 1
    max_value: 100
    step: 1
    mode: BOX
    unit_of_measurement: "mol/m2/day"
    icon: mdi:weather-sunny
    restore_value: True
    retain: True

  - platform: template
    name: "Temperature Max [${area_id}${suffix}]"
    id: ${area_id}_temperature_max
    state_topic: "${area_id}/temperature_max"
    command_topic: "${area_id}/temperature_max/set-state"
    optimistic: True
    initial_value: 30
    min_value: 20
    max_value: 35
    step: 1
    mode: BOX
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    restore_value: True
    retain: True

  - platform: template
    name: "Day Length Vegetative [${area_id}${suffix}]"
    id: ${area_id}_day_length_vegetative
    state_topic: "${area_id}/day_length_vegetative"
    command_topic: "${area_id}/day_length_vegetative/set-state"
    optimistic: True
    initial_value: 18
    min_value: 0
    max_value: 24
    step: 1
    mode: BOX
    icon: mdi:weather-sunset-up
    restore_value: True
    retain: True

  - platform: template
    name: "Day Length Generative [${area_id}${suffix}]"
    id: ${area_id}_day_length_generative
    state_topic: "${area_id}/day_length_generative"
    command_topic: "${area_id}/day_length_generative/set-state"
    optimistic: True
    initial_value: 12
    min_value: 0
    max_value: 24
    step: 1
    mode: BOX
    icon: mdi:weather-sunset-up
    restore_value: True
    retain: True

  - platform: template
    name: "Start Date (Epoch) [${area_id}${suffix}]"
    id: ${area_id}_start_date
    state_topic: "${area_id}/start_date"
    command_topic: "${area_id}/start_date/set-state"
    optimistic: True
    min_value: 0
    max_value: 2147483647  # Maximum Unix timestamp
    step: 1
    initial_value: 0
    mode: BOX
    restore_value: True
    retain: True

  - platform: template
    name: "Duration Vegetative [${area_id}${suffix}]"
    id: ${area_id}_duration_vegetative
    state_topic: "${area_id}/duration_vegetative"
    command_topic: "${area_id}/duration_vegetative/set-state"
    optimistic: True
    min_value: 0
    max_value: 365
    step: 1
    initial_value: 30
    mode: BOX
    unit_of_measurement: "days"
    restore_value: True
    retain: True

  - platform: template
    name: "Duration Flipping [${area_id}${suffix}]"
    id: ${area_id}_duration_flipping
    state_topic: "${area_id}/duration_flipping"
    command_topic: "${area_id}/duration_flipping/set-state"
    optimistic: True
    min_value: 0
    max_value: 365
    step: 1
    initial_value: 10
    mode: BOX
    unit_of_measurement: "days"
    restore_value: True
    retain: True

  - platform: template
    name: "Duration Generative [${area_id}${suffix}]"
    id: ${area_id}_duration_generative
    state_topic: "${area_id}/duration_generative"
    command_topic: "${area_id}/duration_generative/set-state"
    optimistic: True
    min_value: 0
    max_value: 365
    step: 1
    initial_value: 50
    mode: BOX
    unit_of_measurement: "days"
    restore_value: True
    retain: True

  - platform: template
    name: "Duration Drying [${area_id}${suffix}]"
    id: ${area_id}_duration_drying
    state_topic: "${area_id}/dutation_drying"
    command_topic: "${area_id}/dutation_drying/set-state"
    optimistic: True
    min_value: 0
    max_value: 365
    step: 1
    initial_value: 15
    mode: BOX
    unit_of_measurement: "days"
    restore_value: True
    retain: True

  - platform: template
    name: "Sunrise Time (Seconds from Midnight) [${area_id}${suffix}]"
    id: ${area_id}_sunrise_time
    state_topic: "${area_id}/sunrise_time"
    command_topic: "${area_id}/sunrise_time/set-state"
    optimistic: True
    min_value: 0
    max_value: 86400  # Maximum seconds in a day
    step: 1
    initial_value: 21600
    mode: BOX
    unit_of_measurement: "seconds"
    restore_value: True
    retain: True

  - platform: template
    name: "Door Open Brightness [${area_id}${suffix}]"
    id: ${area_id}_door_open_brightness
    state_topic: "${area_id}/brightness/door_open"
    optimistic: True
    min_value: 0
    max_value: 1
    step: 0.01
    initial_value: 0.1
    mode: BOX
    unit_of_measurement: "%"
    restore_value: True
    retain: True

interval:
  - interval: 5s  # Adjust as needed
    then:
      - script.execute: check_cola_distance

  - interval: 30s
    then:
      - script.execute: adjust_brightness
    

script:
  - id: check_cola_distance
    then:
      - lambda: |-
          // Get the current cola distance and threshold values
          float _cola_distance = id(${area_id}_canopy_cola_distance).state;
          float cola_distance_threshold = id(${area_id}_cola_distance_threshold).state;

          // Check if the door is closed and cola distance is below the threshold
          if (!id(${area_id}_door_open${suffix}) && _cola_distance < cola_distance_threshold) {
            ESP_LOGD("cola_distance_check", "Cola distance detected: %.2f m, below threshold of %.2f m, and door is closed.", _cola_distance, cola_distance_threshold);

            // Publish MQTT message if the condition is met (true)
            id(mqtt_publish_cola_detected_true).execute();
          } else {
            ESP_LOGD("cola_distance_check", "No cola detected or door is open.");

            // Publish MQTT message if the condition is not met (false)
            id(mqtt_publish_cola_detected_false).execute();
          }

  - id: mqtt_publish_cola_detected_true
    then:
      - mqtt.publish:
          topic: "${area_id}/canopy/sensor/cola_detected"
          payload: !lambda |-
            ESP_LOGD("mqtt_publish", "Publishing Cola Detected: true");
            return std::string("{\"state\": \"true\"}");

  - id: mqtt_publish_cola_detected_false
    then:
      - mqtt.publish:
          topic: "${area_id}/canopy/sensor/cola_detected"
          payload: !lambda |-
            ESP_LOGD("mqtt_publish", "Publishing Cola Detected: false");
            return std::string("{\"state\": \"false\"}");

  - id: adjust_brightness
    then:
      - lambda: |-
          // Get current PPFD and target PPFD values
          float ppfd_target = id(${area_id}_canopy_ppfd_target).state;
          float new_brightness = id(${area_id}_door_open_brightness).state;

          if (ppfd_target < 0.01) {  // Using a small threshold for floating-point comparison
            // PPFD target is zero, turn off the light
            new_brightness = 0.0;
          } else {
            if (!id(${area_id}_door_open${suffix})) {
              // Get current brightness from the number sensor state
              float current_brightness = id(full_spectrum_brightness_number_sensor).state;

              // Get current PPFD and target PPFD values
              float ppfd = id(${area_id}_canopy_ppfd).state;

              // Log the current state of PPFD and brightness
              ESP_LOGD("brightness_control", "Current PPFD: %.2f", ppfd);
              ESP_LOGD("brightness_control", "Target PPFD: %.2f", ppfd_target);
              ESP_LOGD("brightness_control", "Current Brightness: %.2f", current_brightness);

              // Calculate the error and adjustment needed
              float error_value = ppfd_target - ppfd;
              float adjustment = error_value / 2000.0;  // Increase divisor for less aggressive adjustment

              // Log the error and adjustment value
              ESP_LOGD("brightness_control", "Error Value: %.2f", error_value);
              ESP_LOGD("brightness_control", "Adjustment Value: %.5f", adjustment);

              // Calculate new brightness value
              new_brightness = current_brightness + adjustment;
            }
          }

          // Ensure brightness stays between 0 and 1
          if (new_brightness > 1.0) {
            new_brightness = 1.0;
          } else if (new_brightness < 0.0) {
            new_brightness = 0.0;
          }

          // Log the new brightness value after clamping
          ESP_LOGD("brightness_control", "New Brightness (after clamping): %.2f", new_brightness);

          // Update the global variable with the new brightness value
          id(${area_id}_new_brightness_global${suffix}) = new_brightness;

      - mqtt.publish:
          topic: "${area_id}/light/full_spectrum/set-state"
          payload: !lambda |-
            if (id(${area_id}_new_brightness_global${suffix}) > 0.0 && id(${area_id}_dayphase_target).state) {
              ESP_LOGD("mqtt_publish", "Publishing Brightness ON: %d", (int)(id(${area_id}_new_brightness_global${suffix}) * 255));
              return std::string("{\"state\": \"ON\", \"brightness\": ") + std::to_string((int)(id(${area_id}_new_brightness_global${suffix}) * 255)) + "}";
            } else {
              ESP_LOGD("mqtt_publish", "Publishing Brightness OFF");
              return std::string("{\"state\": \"OFF\", \"brightness\": 0}");
            }

