id: adjust_brightness
then:
- lambda: |-
    // Get current PPFD and target PPFD values
    float ppfd_target = id(${area_id}_${device_id}${suffix}_ppfd_target).state;
    float new_brightness = id(${area_id}_${device_id}${suffix}_door_open_brightness).state;

    if (ppfd_target < 0.01) {  // Using a small threshold for floating-point comparison
        // PPFD target is zero, turn off the light
        new_brightness = 0.0;
    } else {
        if (!id(${area_id}_${device_id}${suffix}_door_open)) {
            // Get current brightness from the number sensor state
            float current_brightness = id(${area_id}_${device_id}${suffix}_full_spectrum_brightness).state;

            // Check if new_brightness is NaN and set to 0 if true
            if (isnan(current_brightness)) {
                ESP_LOGW("brightness_control", "New brightness is NaN. Setting to 0.");
                current_brightness = 0;
            }
            
            // Get current PPFD and target PPFD values
            float ppfd = id(${area_id}_${device_id}${suffix}_ppfd).state;

            // Log the current state of PPFD and brightness
            ESP_LOGD("brightness_control", "Current PPFD: %.2f", ppfd);
            ESP_LOGD("brightness_control", "Target PPFD: %.2f", ppfd_target);
            ESP_LOGD("brightness_control", "Current Brightness: %.2f", current_brightness);

            // Calculate the error and adjustment needed
            float error_value = ppfd_target - ppfd;
            // if the error is large, a large divisor is used to make the adjustment less aggressive
            float divisor = 2000.0;
            float adjustment = error_value / divisor;  // Increase divisor for less aggressive adjustment

            // Log the error and adjustment value
            ESP_LOGD("brightness_control", "Error Value: %.2f", error_value);
            ESP_LOGD("brightness_control", "Adjustment Value: %.5f", adjustment);

            // Calculate new brightness value
            new_brightness = current_brightness + adjustment;
        }
    }

    // Ensure brightness stays between 0 and 1
    if (new_brightness > 1.0) {
        new_brightness = 1.0;
    } else if (new_brightness < 0.0) {
        new_brightness = 0.0;
    }

    // Log the new brightness value after clamping
    ESP_LOGD("brightness_control", "New Brightness (after clamping): %.2f", new_brightness);

    // Update the global variable with the new brightness value
    id(${area_id}_${device_id}${suffix}_new_brightness_global) = new_brightness;

- mqtt.publish:
    topic: "${area_id}/full_spectrum/state/QBAR/set"
    payload: !lambda |-
        if (id(${area_id}_${device_id}${suffix}_new_brightness_global) > 0.0 && id(${area_id}_${device_id}${suffix}_dayphase_target).state) {
            ESP_LOGD("mqtt_publish", "Publishing Brightness ON: %d", (int)(id(${area_id}_${device_id}${suffix}_new_brightness_global) * 255));
            return std::string("{\"state\": \"ON\", \"brightness\": ") + std::to_string((int)(id(${area_id}_${device_id}${suffix}_new_brightness_global) * 255)) + "}";
        } else {
            ESP_LOGD("mqtt_publish", "Publishing Brightness OFF");
            return std::string("{\"state\": \"OFF\", \"brightness\": 0}");
        }
