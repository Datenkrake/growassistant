# Enable Home Assistant API
#api:
#  encryption:
#    key: "8sqEZlrTkjDFp0bb4h3RB4ARMPuGqPkUbt4u/7GmHOE="

ota:
  - platform: esphome
    password: "0772ced7e23b72a0f24919c3c987d5b0"

# Enable Home Assistant API
#api:
#  encryption:
#    key: "mDqnqri8IqixzLdB16qmvlcDVeNiqwjynMLD7gPI0gs="

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

esphome:
  name: "g3v-brain"

####################################################################
# configure substitutions and friendly name
####################################################################

  area: ${area_id}
  friendly_name: ${area_id}_${device_id}${suffix}

# Note for pinout on ESP32-C3 Supermini:
# Pin Functions
# GPIO0 / A0 (bottom right corner in top view with USB port on the top)
# GPIO1 / A1
# GPIO2 / A2 (external pull-up resistor and is a boot related pin)
# GPIO3 / A3
# GPIO4 / A4 / SCK
# GPIO5 / A5 / MISO
# GPIO6 / MOSI
# GPIO7 / SS
# GPIO8 / SDA
# GPIO9 / SCL (external pull-down resistor and is a boot related pin "BOOT button")
# GPIO10
# GPIO20 / RX
# GPIO21 / TX

substitutions:
  area_id: G3V
  device_id: "BRAIN"
  suffix: ""

  pin_sda: GPIO9
  pin_scl: GPIO8
  pin_fan1_pwm: GPIO21
  pin_fan2_pwm: GPIO7
  pin_humidifier: GPIO0
  pin_heater_pwm_helper: GPIO1
  address_sht4x: "0x44"

####################################################################
# generic yaml for humidifiers below
####################################################################
logger:
captive_portal:
wifi:
  !include includes/wifi_default.yaml

i2c:
  !include includes/i2c_bus_a.yaml

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  topic_prefix: "auto/${area_id}/${device_id}"
  log_topic: "debug/${area_id}/${device_id}"
  client_id: 'mqtt_client'

time:
  - !include includes/time_mqtt.yaml

output:
  - platform: slow_pwm
    pin: ${pin_humidifier}
    id: ${area_id}_${device_id}${suffix}_pwm_output
    period: 10s

  - platform: ledc
    pin: ${pin_fan2_pwm}
    id: ${area_id}_${device_id}${suffix}_exhaust_pwm
    frequency: 25000 Hz
    inverted: True
    max_power: 1.0

  - platform: ledc
    pin: ${pin_fan1_pwm}
    id: ${area_id}_${device_id}${suffix}_wind_pwm
    frequency: 25000 Hz
    inverted: True
    max_power: 1.0

fan:
  - platform: speed
    output: ${area_id}_${device_id}${suffix}_pwm_output
    name: "Humidifier [${area_id}_${device_id}${suffix}]"
    id: ${area_id}_${device_id}${suffix}_humidifier
    speed_count: 100  # Set the speed steps (0-100%)
    state_topic: "${area_id}/fan/state/HUMIDIFIER"
    speed_state_topic: "${area_id}/fan/speed/HUMIDIFIER"
    command_topic: "${area_id}/fan/state/HUMIDIFIER/set"
    speed_command_topic: "${area_id}/fan/speed/HUMIDIFIER/set"

  - platform: speed
    output: ${area_id}_${device_id}${suffix}_exhaust_pwm
    name: "Exhaust [${area_id}${suffix}]"
    id: ${area_id}_${device_id}${suffix}_exhaust
    state_topic: "${area_id}/fan/state/EXHAUST"
    speed_state_topic: "${area_id}/fan/speed/EXHAUST"
    command_topic: "${area_id}/${device_id}/fan/state/EXHAUST/set"
    speed_command_topic: "${area_id}/fan/speed/EXHAUST/set"

  - platform: speed
    output: ${area_id}_${device_id}${suffix}_wind_pwm
    name: "Wind [${area_id}${suffix}]"
    id: ${area_id}_${device_id}${suffix}_wind
    state_topic: "${area_id}/fan/state/WIND"
    speed_state_topic: "${area_id}/fan/speed/WIND"
    command_topic: "${area_id}/${device_id}/fan/state/WIND/set"
    speed_command_topic: "${area_id}/fan/speed/WIND/set"

sensor:
  # PHYSICAL SENSORS
  ## TEMPERATURE, HUMIDITY
  - platform: htu21d
    model: htu21d
    temperature:
      name: "Temperature SHT [${area_id}_${device_id}${suffix}]"
      id: ${area_id}_${device_id}${suffix}_temperature
      state_topic: "${area_id}/temperature/state/CANOPY"
      filters:
        - sliding_window_moving_average:
            window_size: 30
            send_every: 10
    humidity:
      name: "Humidity SHT [${area_id}_${device_id}${suffix}]"
      id: ${area_id}_${device_id}${suffix}_humidity
      state_topic: "${area_id}/humidity/state/CANOPY"
      filters:
        - sliding_window_moving_average:
            window_size: 30
            send_every: 10
    heater:
      name: "Heater"
    update_interval: 1s  
    
    
  # CALCULATED SENSORS
  ## CLIMATE
  - !include includes/sensor_vpd.yaml # depends on having temperature and humidity entities from a sensor
  - !include includes/sensor_rh_target.yaml # depends on having temperature and vpd_target entities
  # MQTT
  ## SCHEDULE
  - !include includes/sensor_sunrise_time_hours.yaml
  # MQTT
  - !include includes/sensor_full_spectrum_brightness.yaml

binary_sensor:
  # LIGHT SWITCH
  #- !include includes/binary_sensor_day_phase_target.yaml
  - platform: template
    name: "Day Phase Target [${area_id}_${device_id}${suffix}]"
    id: ${area_id}_${device_id}${suffix}_dayphase_target
    state_topic: "${area_id}/dayphase_target/state/${device_id}"
    lambda: |-
        // Get the current timestamp
        time_t now = id(mqtt_time).now().timestamp;

        // Extract today's date
        struct tm timeinfo;
        localtime_r(&now, &timeinfo);

        // Calculate midnight today
        timeinfo.tm_hour = 0;
        timeinfo.tm_min = 0;
        timeinfo.tm_sec = 0;
        time_t midnight_today = mktime(&timeinfo);

        // Calculate midnight yesterday
        time_t midnight_yesterday = midnight_today - 86400; // Subtract 24 hours in seconds

        // Get sunrise times
        time_t sunrise_today = midnight_today + (time_t) id(${area_id}_${device_id}${suffix}_sunrise_time)->state;
        time_t sunrise_yesterday = midnight_yesterday + (time_t) id(${area_id}_${device_id}${suffix}_sunrise_time)->state;

        // Get day length in seconds
        int day_length_seconds = (int)(id(${area_id}_${device_id}${suffix}_day_length_vegetative)->state * 3600);

        // Determine if it's day phase
        bool is_day = false;

        if (now >= sunrise_yesterday && now < (sunrise_yesterday + day_length_seconds)) {
        is_day = true;
        } else if (now >= sunrise_today && now < (sunrise_today + day_length_seconds)) {
        is_day = true;
        }

        // Log the important time values
        //ESP_LOGD("day_phase_target", "Current Time: %ld", now);
        //ESP_LOGD("day_phase_target", "Midnight Today: %ld", midnight_today);
        //ESP_LOGD("day_phase_target", "Midnight Yesterday: %ld", midnight_yesterday);
        //ESP_LOGD("day_phase_target", "Sunrise Yesterday: %ld", sunrise_yesterday);
        //ESP_LOGD("day_phase_target", "Sunrise Today: %ld", sunrise_today);
        //ESP_LOGD("day_phase_target", "Day Length (seconds): %d", day_length_seconds);
        //ESP_LOGD("day_phase_target", "Is it day phase? %s", is_day ? "Yes" : "No");

        return is_day;

switch:
  - !include includes/switch_enable.yaml

number:
  - !include includes/number_temperature_max.yaml
  - !include includes/number_vpd_target.yaml
  - !include includes/number_leaf_offset.yaml
  - !include includes/number_fan_speed_min.yaml
  - !include includes/number_fan_speed_max.yaml
  - !include includes/number_wind_sweep_duration.yaml
  ## SCHEDULING
  - !include includes/number_start_date.yaml
  - !include includes/number_sunrise_time.yaml
  - !include includes/number_day_length_vegetative.yaml
  - platform: template
    name: "Light Percent [${area_id}_${device_id}${suffix}]"
    id: ${area_id}_${device_id}${suffix}_light_percent
    state_topic: "${area_id}/light_percent/state/${device_id}"
    command_topic: "${area_id}/light_percent/state/${device_id}/set"
    optimistic: true
    initial_value: 0
    min_value: 0
    max_value: 100
    step: 1
    mode: BOX
    unit_of_measurement: "%"
    restore_value: True
    retain: True

interval:
  - interval: 60s
    then:
      - script.execute: update_humidifier_speed
      - script.execute: publish_humidifier_speed
      - script.execute: publish_humidifier_speed_govee
      - script.execute: update_exhaust_fan_speed
      - script.execute: update_wind_fan_speed
      - script.execute: ${area_id}_${device_id}${suffix}_publish_wind_fan_speed
      - script.execute: ${area_id}_${device_id}${suffix}_publish_exhaust_fan_speed
      - script.execute: adjust_brightness_shelly_dimmer
      - script.execute: update_heater

globals:
  - id: ${area_id}_${device_id}${suffix}_exhaust_fan_pwm_value
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${area_id}_${device_id}${suffix}_fan_speed_step
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${area_id}_${device_id}${suffix}_new_brightness_global
    type: float
    restore_value: no
    initial_value: '0.0'

script:
  #- !include includes/script_update_humidifier_speed.yaml
  #- !include includes/script_adjust_brightness_shelly_dimmer.yaml

  - id: ${area_id}_${device_id}${suffix}_publish_wind_fan_speed
    then:
      - mqtt.publish:
          topic: "${area_id}/fan/speed/WIND"
          payload: !lambda 'return std::to_string(id(${area_id}_${device_id}${suffix}_wind).speed);'

  - id: ${area_id}_${device_id}${suffix}_publish_exhaust_fan_speed
    then:
      - mqtt.publish:
          topic: "${area_id}/fan/speed/EXHAUST"
          payload: !lambda 'return std::to_string(id(${area_id}_${device_id}${suffix}_exhaust).speed);'

  - id: publish_humidifier_speed
    then:
      - mqtt.publish:
          topic: "${area_id}/fan/speed/HUMIDIFIER"
          payload: !lambda 'return std::to_string(id(${area_id}_${device_id}${suffix}_humidifier).speed);'

  - id: update_heater
    then:
      - if:
          condition:
            lambda: |-
              float current = id(${area_id}_${device_id}${suffix}_temperature).state;
              float lower = id(${area_id}_${device_id}${suffix}_temperature_max).state - 1;
              ESP_LOGD("update_heater", "Current: %.1f, Lower Threshold: %.1f", current, lower);
              return current < lower;
          then:
            - mqtt.publish:
                topic: "${area_id}/mains/heat/command/switch:0"
                payload: "on"
            - lambda: |-
                ESP_LOGD("update_heater", "Heater turned ON (temp below lower threshold)");
      - if:
          condition:
            lambda: |-
              float current = id(${area_id}_${device_id}${suffix}_temperature).state;
              float upper = id(${area_id}_${device_id}${suffix}_temperature_max).state + 1;
              ESP_LOGD("update_heater", "Current: %.1f, Upper Threshold: %.1f", current, upper);
              return current > upper;
          then:
            - mqtt.publish:
                topic: "${area_id}/mains/heat/command/switch:0"
                payload: "off"
            - lambda: |-
                ESP_LOGD("update_heater", "Heater turned OFF (temp above upper threshold)");

  - id: update_humidifier_speed
    then:
      - lambda: |-
          // Turn on the humidifier
          auto call_on = id(${area_id}_${device_id}${suffix}_humidifier).turn_on();
          call_on.perform();
          ESP_LOGD("humidifier", "Turning on humidifier.");

          // Retrieve RH targets
          float rh_target = id(${area_id}_${device_id}${suffix}_rh_target).state;
          ESP_LOGD("humidifier", "RH Target: %.2f%%", rh_target);

          // Retrieve current RH
          float rh = id(${area_id}_${device_id}${suffix}_humidity).state;

          // Calculate RH difference
          float rh_difference = rh_target - rh;
          ESP_LOGD("humidifier", "RH difference: %.2f%%", rh_difference);

          // Check if rh_target is valid
          if (std::isnan(rh_target)) {
            ESP_LOGW("humidifier", "RH Target is NaN. Skipping speed adjustment.");
            return;
          }

          // Retrieve current humidifier speed
          int current_speed = id(${area_id}_${device_id}${suffix}_humidifier).speed;
          // Validate current_speed, ensure it is within 0-100%
          if (current_speed < 0 || current_speed > 99) {
            ESP_LOGW("humidifier", "Invalid current_speed (%d%%). Resetting to 0%%.", current_speed);
            current_speed = 99;
            id(${area_id}_${device_id}${suffix}_humidifier).speed = current_speed;
          }
          ESP_LOGD("humidifier", "Current Humidifier Speed: %d%%", current_speed);

          // Define minimum RH difference to trigger adjustment (e.g., 1%)
          const float min_rh_diff = 0.2;

          // Round the RH difference to the nearest integer
          int error = roundf(rh_difference);
          ESP_LOGD("humidifier", "Rounded error: %d%%", error);

          // Adjust humidifier speed based on RH comparison with hysteresis
          if (error > min_rh_diff) {
            // Increase speed by error, ensuring it doesn't exceed 100%
            int new_speed = std::min(current_speed + error, 100);
            id(${area_id}_${device_id}${suffix}_humidifier).speed = new_speed;
            ESP_LOGD("humidifier", "RH target > current RH by > %.2f%%. Increasing speed to %d%%", min_rh_diff, new_speed);
          } else if (error < -min_rh_diff) {
            // Decrease speed by (abs(error) * 2), ensuring it doesn't go below 0%
            int adjustment = std::abs(error) * 2;
            int new_speed = std::max(current_speed - adjustment, 0);
            id(${area_id}_${device_id}${suffix}_humidifier).speed = new_speed;
            ESP_LOGD("humidifier", "RH target < current RH by > %.2f%%. Decreasing speed to %d%%", min_rh_diff, new_speed);
          } else {
            ESP_LOGD("humidifier", "RH difference within ±%.2f%%. No speed adjustment needed.", min_rh_diff);
          }

  - id: update_exhaust_fan_speed
    then:
      - lambda: |-
          auto call1 = id(${area_id}_${device_id}${suffix}_exhaust).turn_on();
          call1.perform();

          float temperature = id(${area_id}_${device_id}${suffix}_temperature).state;
          float humidity = id(${area_id}_${device_id}${suffix}_humidity).state;
          float rh_target = id(${area_id}_${device_id}${suffix}_rh_target).state;

          // Adjust fan speed based on conditions
          float fan_min = id(${area_id}_${device_id}${suffix}_fan_speed_min).state;
          float fan_max = id(${area_id}_${device_id}${suffix}_fan_speed_max).state;
          float fan_value = id(${area_id}_${device_id}${suffix}_exhaust_fan_pwm_value);

          // Define minimum RH difference to trigger adjustment
          const float min_rh_diff = 0.2;
          float rh_difference = rh_target - humidity;
          int current_speed = id(${area_id}_${device_id}${suffix}_exhaust).speed;
          float new_speed = current_speed;

          // Adjust exhaust fan speed based on RH comparison with hysteresis
          if (rh_difference > min_rh_diff) {
              // RH target > current RH: Decrease speed
              new_speed = std::max(current_speed - roundf(std::abs(rh_difference) * 2), fan_min);
              ESP_LOGD("exhaust", "RH target > current RH by > %.2f%%. Decreasing speed to %.2f%%", min_rh_diff, new_speed);
          } else if (rh_difference < -min_rh_diff) {
              // RH target < current RH: Increase speed
              new_speed = std::min(current_speed + roundf(std::abs(rh_difference) * 0.5), fan_max);
              ESP_LOGD("exhaust", "RH target < current RH by > %.2f%%. Increasing speed to %.2f%%", min_rh_diff, new_speed);
          } else {
              ESP_LOGD("exhaust", "RH difference within ±%.2f%%. No speed adjustment needed.", min_rh_diff);
          }

          // Clamp the fan value between min and max
          new_speed = std::max(fan_min, std::min(fan_max, new_speed));

          // Update the global fan speed value
          id(${area_id}_${device_id}${suffix}_exhaust_fan_pwm_value) = new_speed;
          id(${area_id}_${device_id}${suffix}_exhaust).speed = static_cast<int>(roundf(new_speed));

          ESP_LOGD("exhaust", "Updating fan speed to %.2f%% (Min: %.2f%%, Max: %.2f%%)", new_speed, fan_min, fan_max);

  - id: update_wind_fan_speed
    then:
      - lambda: |-
          auto call1 = id(${area_id}_${device_id}${suffix}_wind).turn_on();
          call1.perform();

          int step = id(${area_id}_${device_id}${suffix}_fan_speed_step);
          int duration = id(${area_id}_${device_id}${suffix}_sweep_duration).state; // Duration in minutes
          //float min_speed = id(${area_id}_${device_id}${suffix}_fan_speed_min).state;
          float min_speed = 50;
          //float max_speed = id(${area_id}_${device_id}${suffix}_fan_speed_max).state;
          float max_speed = 80;

          // Calculate the fan speed by linearly interpolating from min to max over 60 steps (1 hour)
          float fan_speed = min_speed + (max_speed - min_speed) * (step / (float)duration);

          // Increment the step counter, reset after 60 minutes
          id(${area_id}_${device_id}${suffix}_fan_speed_step) = (step + 1) % duration;

          // Set the fan speeds to the calculated value
          id(${area_id}_${device_id}${suffix}_wind).speed = fan_speed;
          ESP_LOGD("fan", "Updating fan speed to %.2f%%", fan_speed);

  - id: adjust_brightness_shelly_dimmer
    then:
        - lambda: |-
            float new_brightness = id(${area_id}_${device_id}${suffix}_light_percent).state;
            ESP_LOGD("brightness_control", "New Brightness: %.2f", new_brightness);
            id(${area_id}_${device_id}${suffix}_new_brightness_global) = new_brightness;

        - mqtt.publish:
            topic: "${area_id}/mains/light/command/switch:0"
            payload: !lambda |-
                ESP_LOGD("brightness_control", "New Brightness Global: %.2f", id(${area_id}_${device_id}${suffix}_new_brightness_global));
                return id(${area_id}_${device_id}${suffix}_dayphase_target).state ? "on" : "off";

        - mqtt.publish_json:
            topic: "${area_id}/light/dimmer/rpc"
            payload: !lambda |-
                if (id(${area_id}_${device_id}${suffix}_new_brightness_global) > 0.0) {
                    int brightness_percent = (int)(id(${area_id}_${device_id}${suffix}_new_brightness_global) * 100);
                    ESP_LOGD("mqtt_publish", "Publishing Brightness: %d%%", brightness_percent);
                    // Construct the JSON payload to turn on the light with specified brightness
                    root["id"] = 1;
                    root["src"] = "user";
                    root["method"] = "Light.Set";
                    auto params = root.createNestedObject("params");
                    params["id"] = 0;
                    params["on"] = true;
                    params["brightness"] = brightness_percent;
                } else {
                    ESP_LOGD("mqtt_publish", "Turning off Light");
                    // Construct the JSON payload to turn off the light
                    root["id"] = 1;
                    root["src"] = "user";
                    root["method"] = "Light.Set";
                    auto params = root.createNestedObject("params");
                    params["id"] = 0;
                    params["on"] = false;
                }


  - id: publish_humidifier_speed_govee
    then:
      - mqtt.publish:
          topic: "gv2mqtt/humidifier/15271091A84F5950/set-target"
          payload: !lambda |-
            float rh_target = id(${area_id}_${device_id}${suffix}_rh_target).state;
            int speed = id(${area_id}_${device_id}${suffix}_humidifier).speed;
            int result = static_cast<int>(rh_target + speed - 10);
            if (result < 40) result = 40;
            if (result > 80) result = 80;
            return std::to_string(result);
